





# shell 编程



## 一. shell 脚本基础知识

### 1. 计算机语言分类



1. 计算机语言一般分为**编译型语言**  和 **解释型语言** . 
   1. 对于**编译型语言** ,我们以C语言举例. 
      - 对于C语言必须先写完C代码, 然后再通过编译器编译, 没有错误以后, 生成可执行文件再运行. 
      - 对于编译型语言有个特点, 无论代码有多长, 只要有一点点的语法错误, 就无法编译通过生成可执行文件.   **就是说编译型语言必须得先编译再执行. ** 
      - 变异型语言用到了编译器, 不同的编译器生成的可执行文件是不一样的.  比如说: 我用`GCC` 编译器,编译出的可执行文件用在`x86平台`的机器上.  比如说将来我换了, 换成 `arm-gcc` 那么这时候他就使用于arm 处理器.  **所以在这里我们要知道, 编译型语言它受到编译器类型的限制** ,  将来不通的编译器,编译出的可执行文件不同跑在不同的平台上. 移植性受影响, 但是效率是比较高的. 
   2. 对于**解释型语言** 
      - 像我们马上要讲的shell 就是解释性语言, 解释性的语言它不像编译型语言要把代码全部编译通过后再一次执行.  它是解释一行执行一样, 我样做是比较灵活, 当然



### 2. shell 脚本的本质

- shell 脚本是解释型语言
- shell 脚本的本质是:** shell 命令的有序集合** 





### 3. shell 编程的基本过程

- 基本过程分为三步:

  - 1. 建立shell文件 (建议以 .sh 结尾)

    >  包含任意多行操作系统命令 或 shell 命令的文本文件

  - 2. 赋予shell 文件执行权限

    >  因为脚本是由命令组成的, 而命令是可以在命令行上直接执行的, 因此shell脚本不需要编译器, 只需要对shell脚本赋予执行权限就可以了. 赋予执行权限后直接在命令行上执行就可以了. 
    >
    > 用 chmod 命令修改权限

    

  - 3. 执行shell 文件

    直接在命令行上调用 shell程序
  
  
  
  



## 二. shell 变量

### 1.  shell 变量的简单使用 



- shell 允许用户定义变量存储数据, 但是不支持数据类型 (整型/ 字符型/ 浮点型), 将任何赋给变量的值都解析为一串字符串

  ```
  # 定义变量count
  count=1			 
  # 输出变量count的值, 需要在变量前添加 $ 符号, 否则会原样输出
  echo $count  
  
  # 定义变量DATE, 
  DATE=`date`  # `` 符号表示的是命令置换, 将date 执行的结果赋值给变量DATE
  echo $DATE
  ```

  **注意:**

  1. shell 中的变量是不支持数据类型的, 所有的变量值都按字符串处理
  2. 定义和赋值shell变量是, 赋值符号`=` 两边不能有空格

  ```
  count=10 # 正确写法
  # 以下是错误写法
  count =10
  count= 10
  count = 10 
  ```

### 2.  shell变量有4种

#### 1. 自定义shell 变量

- 自定义shell变量的规范

  >  在shell 编程中,约定变量名通常全部用大写, 方便识别

  ```
  COUNT=10 #  定义变量
  ```

- 自定义shell变量的调用

  > 在自定义shell变量的前面添加 `$` 美元符号, 表示调用shell变量的值

  ```
  COUNT=20
  echo $COUNT	 # 调用变量
  ```

- shell 变量的赋值

  > 直接使用赋值符号像shell变量赋值即可, 注意赋值符号两边不能有空格

  ```
  COUNT=20
  echo $COUNT	
  COUNT=200   # 变量赋值
  echo $COUNT
  ```

- 使用`unset` 命令删除变量的赋值

  ```
  COUNT=20
  echo $COUNT	
  COUNT=200   
  echo $COUNT
  unset COUNT	# 删除变量的赋值 (相当于是赋值为空格)
  echo $COUNT
  ```

  

#### 2. shell 中获取位置变量(也叫: 命令行参数)

- `$0` : 与键入的命令行一样, 包含脚本文件名
- `$1, $2 ... $9` : 分别获取第一个到第九个命令行参数 **(有坑: 序号超过10,需要用`{}` 包裹,eg: `${11}`)** 
- `$#`: 包含命令行参数的个数
- `#@`: 包含所有的命令行参数: `$1, $2 ... $9`
- `$?` : 包含前一个命令的退出状态
- `$*`: 包含所有命令行参数: `$1, $2 ... $9`
- `$$`: 包含正在执行的进程的ID号

> 在shell 中 `$` 数特殊符号不能当字符串输出, 要输出必须在前面添加`\` 转义字符才能输出

- 下面是test2.sh 中的内容

```
# $0,与键入的命令行一样, 包含脚本文件名
echo "\$0 脚本文件名称: $0"

# $1 $2 ... $9,分别获取第一个到第九个参数
echo "\$1 第一个参数: $1"
echo "\$2 第二个参数: $2"

# 在使用 $+index 时需要注意, 如果index > 9 时需要使用 {} 括起来否则 $10 会被理解为 $1 和字符串0
echo "\$+index, index 超出9需要使用{}包裹: \$10错误写法: $10"
echo "\$10正确写法: ${10}"
echo "\$11正确写法: ${11}"

# $#, 获取参数的个数
echo "\$#  一共有: $# 个参数"

# #@ 获取所有的参数
echo "\$@ 获取所有的参数: $@"

# $? 获取前一个命令的退出状态
echo "\$? 前命令退出状态: $?"

# $* 与 $@ 一样, 都是获取所有的命令参数
echo "\$* 所有的命令参数: $*"

# $$ 获取正在执行的进程ID
echo "\$$ 正在执行的进程: $$"

# 在shell 中$是特殊符号, 要输出需要使用转义符号 \
echo "输出\$0: $0"
```



```
# 终端测试参数
./test2.sh a1 a2 a3 a4 a5 a6 a7 a8 a9 a1_0  a1_1 
```





#### 3. 常用shell 环境变量

> 环境变量和我们在shell 里面自定义的shell 变量不一样, 它是已经在在其他脚本中已经定义好的变量, 环境变量的配置是对我们的代码有直接影响的, 所以要注意一下.
>
> 我们在shell 编程中可以直接使用环境变量, 这是没有问题的

- **HOME**:  当前用户的根目录

- **PATH**: shell 搜索路径

- **TERM**: 终端类型, 常用的有`vt100` `xterm` `vt200` `ansi` 等

- **PS1** / **PS2**: 默认提示符($) 即换行符 (>)

- **IFS** : internal field separator , 默认为空格, tab及换行符

  > 通过命令: `export` 查看所有的环境变量
  >
  > 命令: `env` 也可以查看其它的环境变量





## 三. Shell程序和语句



### 1. shell 中的程序语句介绍



shell 程序由0或多条shell语句构成, shell  语句主要包括三类:

- 说明性语句, 也称为注释语句

  > 以 `#` 号开始到该行结束, 不被解释执行
  >
  > 也就是说, 在shell文件中以`#` 开头的语句都是说明性语句, 注释语句不被执行

  - 虽然说, 在shell 中以`#` 开头的语句是解释语句不被执行, 但是在shell 中写的第一行解释语句 `#! /bin/bash` 是个例外, 这句话直接决定了后面的shell程序将由哪个shell来执行, 这一点需要注意一下

  

- 功能性语句

  > 任意的shell命令, 用户程序, 或其他的shell 程序, 都称为功能性语句
  >
  > 只要是能在命令终端中书写的可执行的语句都可以看做是功能性语句

- 结构性语句

  > 条件测试语句
  >
  > 多路分支语句
  >
  > 循环语句
  >
  > 循环控制语句等



### 2. shell常用功能性语句



#### 1. 输入语句 read

​	有时我们在执行命令时, 命令执行到一定的程度时, 需要让用户输入一些信息, 比如: 我们在执行一个删除功能的shell脚本程序, 程序执行到一半是, 需要验证操作人员的权限, 需要用户从键盘数据一个密码, 这时就需要用到shell 中的 **read** 语句, 类似于C语言中的 **scanf** 语句

- **read**  语句

  > 从标准输入读入一行, 并赋值给后面的变量, 其语法如下:

  ```
  read num   # 将用户输入的内容赋值个shell 变量num
  read num1 num2 num3  # 将用户依次输入的三个数分别赋值给 num1 num2 num3
  ```

  - 注意: 

    当用书在输入内容时, 多个内容之间使用空格分开, 如果用户在输入时,输入的内容个数与read语句后面的shell 变量内容个数相同, 则一一对应赋值给对应的变量, 如果输入的内容个数少于shell 变量个数, 则后面的shell变量为空, 如果输入的内容个数超过shell 变量个数则前面的变量依次对应, 后面的内容不再以空格分隔全部复制个最后一个shell 变量, 也就是说输入内容个数少了, 后面变量为空, 输入内容多了, 最后一个变量中的字符串有空格. 输入回车结束

  ```
  #! /bin/bash
  
  echo "请输入年月日, 中间以空格隔开"
  
  # 输入的内容依次 赋给 year month day 变量
  read year month day
  
  echo "年: $year, 月: $month, 日: $day"
  ```



#### 2. 输出语句 echo

相当于C语言中的 printf 函数



- echo 后面个直接跟内容表示输出

  ```
  echo "hello shell"
  ```

- echo 输出变量的值时要在变量前加 `$`

  ```
  # 输出环境变量的值
  echo $PATH
  ```

- **echo 输出内容不换行** 

  - 方式一, 在 /bin/bash中不换行

  ```
  #!/bin/bash
  
  echo -n "输出的第一行内容"
  echo "输出的第二行内容"		
  ```

  - 方式二, 在/bin/sh中不换行

  ```
  #! /bin/sh
  
  echo "输出的第一行内容\c"
  echo "输出的第二行内容"		
  ```

  

#### 3.算术运算语句 expr  (有坑)

- 算术运算命令**expr**  主要用于进行简单的整数运算, 包括 (+ )  减(-)  乘(*)   整除(/) 求模(%) 等操作

  > 上面的话怎么理解呢? 
  >
  > 也就是说在shell 里面我们要写一个表达式, 不能像在C 语言中一样直接写, 需要在表达式的前面添加 **expr** 命令, 如下

  ```
  expr 3 + 5 \* 3 / 2 % 3
  ```

- **expr** 命令注意点

  - 在shell 中 `*` 表示的是通配符, 如果要表示乘号, 那么需要在前面添加转义符号`\`

  ```
  # 计算 3 * 4
  expr 3 * 4  # 错误写法
  expr 3 \* 4 # 正确写法
  ```

  - 算术运算符两边要有空格, 在C语言中是没有要求的, 但是在shell 中因为是没有数据类型, 所以通常借助 空格来区分

  ```
  expr 3+5 # 错误写法
  expr 3 + 5 # 正确写法
  ```

  - **expr 命令的算术结果不能直接赋值给shell变量, 要使用 ` `` ` 命令置换符号置换后才能赋值**

  ```
  sum=expr 3 + 5  # 错误写法
  sum=`expr 3 + 5` # 正确写法	
  ```

- 完整的示例

  ```
  #!/bin/bash
   
  expr 3 + 5 \* 3 / 2
   
  count=`expr 3 + 5`
  echo $count
  
  num=9
  total=`expr $num \* 3`
  echo $total
  ```

  



#### 4.  测试语句 test (判断语句)

- test 语句可测试(判断)三种对象 `字符串`  `整数`  `文件属性` 

- test 对`字符串` 的测试操作, 主要几种功能:

  - 比较2个字符串是否一样
  - 比较2个字符串是否 有差异
  - 测试一个字符串的长度是否为0 
  - 测试一个字符的长度是否大于0 

  ```
  #!/bin/bash
  
  A="how"
  B="how"  
  test $A = $B 
  # 使用 $? 获取上一条命令的执行结果, 这里刚好是test命令的比较结果
  # 为0表示相等, 非0为不等
  echo $?
   
  # 字符串测试
  #  $p1 = $p2 测试两个字符串是否相当
  #  $p1 != $p2 测试两个字符串是否 有差异
  #  -z $p 测试字符串长度是否为0
  #  -n $p 测试字符串长度是否 大于 
  ```

- test对整数测试主要有以下几种 

  ```
  #!/bin/bash
  
  num1=20
  num2=40
  test $num1 -eq $num2
  echo $?
  
  # 整数测试
  # $a -eq $b 测试整数 是否相等
  # $a -ne $b 测试整数 是否 不相等
  # $a -gt $b 测试整数 a > b
  # $a -ge $b 测试整数 a >= b
  # $a -lt $b 测试整数 a < b
  # $a -le $b 测试整数 a <= b
  ```

  

- test对文件属性的测试主要有以下几种 

  - 测试 `tmp` 是否是一个目录名

  ```
  # 文件测试
  # -d $fileName 测试是否是一个目录
  -e $fileName 测试文件是否存在
  -f $fileName 测试是否是普通文件
  -L $fileName 测试是否为符号链接
  -r $fileName 测试文件是否存在,且为可读
  -w $fileName 测试文件是否存在,且为可写
  -x $fileName 测试文件是否存在,且为可执行
  -s $fileName 测试文件是否存在,且为长度不为0
  $f1 -nt f2 测试文件f1 是否比f2 新
  $f1 -nt f2 测试文件f1 是否比f2 旧
  ```
#### 1.test命令使用注意点

test 命令测试条件成立时, 命令返回值为(0), 否则返回值为假 (非0)

- 方式1:

  ```
  test $name -eq $1
  echo $?
  ```

- 方式2:

  ```
  if test -f $filename
  then
    ...
  fi
  ```

- 方式3:

  ```
  if [ -f $filename ]
  then 
    ...
  fi
  ```

  **说明:**

  方式3等价于方式2的写法, 	其实 `[ ]` 就相当于是调用 `test`命令, 注意的是 `[ ]` 要用空格隔开  

  

# 四. shell 编程分支语句

 

## 1. 条件分支语句



### 1.条件分支语句 (if 分支语句)

- `if ... then ... fi` 

  >  相当于C语言中的 `if() { }` 语句 

  ```
  # 标准写法:
  if [ 表达式条件 ]
  then
  echo "条件表达式为真"
  fi
  ```

  ```
  # 相当于下面的C语言中的写法
  if (表达式条件){
  	printf("条件表达式为真");
  }
  ```

  

### 2.条件分支语句 (if else分支语句)

- `if ... then ... else ... fi`

  > 相当于C语言中的 `if(){ }else{ }` 语句

   ```
  # 标准写法
  if [ 表达式条件 ]
  then
  	echo "条件表达式为真"
  else
  	echo "条件表达式为假"
  fi
   ```

  ```
  #   C 语言等价写法
  if (表达式条件){
  	printf("条件表达式为真");
  }
  else{
  	printf("条件表达式为假");
  }
  ```

  

### 3.条件分支语句 (if elseif分支语句)

- `if ... then .. elif ... then ... fi`

  > 相当于C语言中的 `if(){}else if(){}`

  ```
  # !/bin/bash
  
  if [ $1 -eq 1 ]
  then
  	echo "输入的是1"
  elif [ $1 -eq 2 ]
  then
  	echo "输入的是2"
  elif [ $1 -eq 3 ]
  then
  	echo "输入的是3"
  elif [ $1 -eq 4 ]
  then
  	echo "输入的是4" 
  fi
  ```



### 4.条件分支语句 (if elseif else分支语句)

- if ... then ... elif ... then ... else ... fi`

  > 相当于C 语言中的 `if(){}else if(){}else{}`

  ```
  # !/bin/bash
  
  if [ $1 -eq 1 ]
  then
  	echo "输入的是1"
  elif [ $1 -eq 2 ]
  then
  	echo "输入的是2"
  elif [ $1 -eq 3 ]
  then
  	echo "输入的是3"
  elif [ $1 -eq 4 ]
  then
  	echo "输入的是4"
  else  
  	echo "输入的是其他" 
  fi
  ```

  

## 2. 多分支语句

- 多分支标准示例

  ```
  # !/bin/bash
  
  echo -n "请输入: yes 或 no "   # 打印不换行
  read rst
  
  #多分支语句 相当于是 switch case 语句
  case $rst in   # 多分支语句开始
  	yes | Yes | YES | Y | y)   # 多个满足, 多重满足 
  		echo "输入的是 yes"
  		;;  
  	no) 
  		echo "输入的是 no"
  		;;
  	n)
  		echo "输入的是 n"
  		;;
  	*) 		# 相当于C语言中的default
  		echo "输入的是其它"
  		;;
  	esac   # 多分支语句结束
  ```





- 多分支分数判断

  ```
  # !/bin/bash
  
  echo -n "请输入你的考试分数: "   # 打印不换行
  read score
  
  if [ $score -lt 0 -o $score -gt 100 ] # -o 相当于C于洋中的 || 或者的意思
  then
  	echo "成绩只能是 0~100 之间的范围"
  	exit # 相当于是C语言中的return
  fi
  
  # 将结果简化分类
  sc=`expr $score / 10`  # 命令置换
  case $sc in
  	9 | 10)
  		echo "$score 成绩优秀"
  		;;
  	6 | 7 | 8)
  		echo "$score 成绩良好"
  		;;
  	*)
  		echo "$score 成绩不及格"
  		;;
  esac
  ```

  



 # 五. shell 循环语句

## 1.  for 循环分支语句

- for 循环语法

  ```
  for 变量名 in 单词表
  do	
  	命令表
  done
  
  变量名依次取单词表中的各个单词, 每取依次单词, 就执行一次魂环体中的 命令. 循环次数由单词表中的单词数确定
  
  命令表中的命令可以是一条, 也可以是由分号或者换行符分开的多条
  ```

  



- 写法1:

  ```
  # !/bin/bash
  
  # 遍历  1 3 5 7 9 
  for i in 1 3 5 7 9  
  do
  	 echo $i
  done
  ```

- 写法2: 

  ```
  # !/bin/bash
  
  # seq 是获取一个序列的命令, 有3个参数
  # 参数1, 表示的是开始值
  # 参数2, 表示的是 递增值 , 可以省略默认是1
  # 参数3, 表示的是 结束值
  
  echo `seq 1 2 10`   # 获取1 3 5 7 9 共计5个数
  
  for i in `seq 1 2 20` 
  do
  	echo $i
  done    
  ```

- 写法3:

  ```
  # !/bin/bash
  
  for ((i = 0; i <= 10; i++))
  do 
  	echo $i
  done
  ```

- 死循环:

  ```
  # !/bin/bash
  
  index=0
  
  # shell 中的for 实现死循环
  for (( ; ; ))
  do 
  	index=`expr $index + 1`
  	echo "死循环: $index" 
  	if [ $index -gt 100 ]
  then
  	exit
  fi
  done
  ```



## 2. demo

拷贝当前目录下所有文案到子目录下





